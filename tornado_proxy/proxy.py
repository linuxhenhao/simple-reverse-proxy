#!/usr/bin/env python
# -*- coding: utf-8 -*-
#####################################################
# A tornado based reverse proxy with builtin filters and
# self dns resolve abilities
# ##################################################

from tornado import web, gen, httpclient
import sys
if sys.version_info[0] < 3:  # in python 2
    from urlparse import urlparse
else:
    from urllib.parse import urlparse


class ProxyHandler(web.RequestHandler):
    SUPPORTED_METHODS = ('GET', 'HEAD', 'POST')
    # for proxy purpose, get head and post methods are enough

    def initialize(self, configd, router, page_filters):
        # initiate a async http client for forwarding incoming requests
        self._client = httpclient.AsyncHTTPClient()
        self._configd = configd  # handler config dict
        self._router = router
        self._filters = page_filters

    def compute_etag(self):
        # disable tornado's etag
        return None

    @gen.coroutine
    def get(self):
        redirected = self._route.redirect(self.request)
        # the requested url not in our router, return 404 page
        if(redirected is None):
            self.set_status(404)
            self.write('<p align="center">page not found!</p>')
            self.finish()
        else:
            url, m_headers = redirected
            response = yield self._client.fetch(
                            url,
                            method=self.request.method,
                            follow_redirects=False,
                            headers = m_headers,
                            allow_ipv6=self._configd['allow_ipv6'])
            # set status code for tornado's response
            self.set_status(response.code)

            # modify response's headers and body using filter
            self._filters.filt(response)

            # modify returned headers, return host (url, r_headers) tuple
            host_url, r_headers = self._router.reverse(response)
            for header in r_headers:
                self.set_header(header, r_headers[header])
            # content length will be automaticly generated by tornado
            self.write(response.body)
            self.finish()

    # using self.get to do post and head proxies
    post = get
    head = get


class Router(object):
    '''
    Router is used to redirect url and related headers of incoming requests,
    The redirection obay the rules defined in settings.py
    INPUT: request
    OUTPUT: target url and modifiled headers
    '''
    def __init__(self, rules):
        '''
        @param list rules: (origin_url, target_url) tuple in a list
        '''
        self._forward_rules, self._reverse_rules = self._gen_rules_d(rules)

    def _gen_rules_d(self, rules):
        '''
        @param list rules: rules [('scheme:host', 'scheme:target')]
        due to the fact that linear search one by one is so ineffective,
        convert rules into two different dict
        '''
        forward_dict = dict()
        reverse_dict = dict()
        for host_str, target_str in rules:
            forward_dict[host_str] = target_str
            reverse_dict[target_str] = host_str
        return forward_dict, reverse_dict

    def redirect(self, request):
        # the request object constructed from recieved request always do
        # not have scheme and host info
        host = request.headers['Host']
        host_str = ":".joint(request.protocol, host)

        # get target scheme:host string
        target_str = self._forward_rules.get(host_str, None)
        if(target_str is None):
            return None
        else:
            scheme, host = target_str.split(":", maxsplit=1)
            # using maxsplit=1 to avoid unwanted split in url if other colon
            # exists in url
            url = scheme + "://" + host + urlparse(request.path)
            return (url, headers)

    def reverse(self, response):
        headers = dict()
        for header in response.headers.get_all():
            if header not in ('Content-Length', 'Transfer-Encoding',
                              'Content-Encoding', 'Connection'):
                # let tornado set these parameters, do not use those in
                # response.headers
                headers[header]  = response.headers[header]
        return (host_url, headers)
